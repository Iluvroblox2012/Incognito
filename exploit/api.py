from rbx.base import fetch_roblox_pid, initialize, initialize_script_hook, random_string
from rbx.bytecode import Bytecode as RBXBytecode

from rbx.bridge import Bridge as RBXBridge
from rbx.instance import Instance, FetchRenderView, Process, Offsets
from rbx.bridge_callbacks import register_callbacks

from ui.manager import EventManager

import misc.init_script as init_script

import time, os, base64, psutil

DEFAULT_CLIENT_INFO = [-1, None]

init_script_bytecode = None
if init_script.debug_mode:
    init_script_bytecode = RBXBytecode.Compile(init_script.content)
else:
    bytecode = base64.b64decode(init_script.content.encode(encoding="ascii", errors="ignore"))
    init_script_bytecode = [bytecode, len(bytecode)]

class ExploitAPI:
    InjectStatus = 0
    CurrentPID = -1

    BridgeService = None

    def __init__(self, Key):
        KeyCheck = not Key > (time.timezone + time.process_time())
        self.BridgeService = RBXBridge()

        if KeyCheck:
            self.InjectStatus = 1

    def Inject(self):
        if self.InjectStatus > 2 and self.CurrentPID == fetch_roblox_pid():
            return self.InjectStatus, "", DEFAULT_CLIENT_INFO

        success, reason, new_pid = initialize()
        if not success:
            return success, reason, DEFAULT_CLIENT_INFO

        print("roblox pid: " + str(new_pid))
        self.InjectStatus = 3
        self.CurrentPID = new_pid

        RenderView = FetchRenderView(new_pid)
        if not RenderView:
            return False, "Failed to fetch RenderView :(", DEFAULT_CLIENT_INFO

        DataModelAddyHolder = Process.read_longlong(RenderView + Offsets.DataModelHolder)
        DataModelAddy = Process.read_longlong(DataModelAddyHolder + Offsets.DataModel) if DataModelAddyHolder else None
        if not (DataModelAddy and DataModelAddy > 1000):
            self.InjectStatus = 1
            return False, "Failed to fetch DataModel :(", DEFAULT_CLIENT_INFO

        DataModel = Instance(DataModelAddy)
        print(DataModel)

        CoreGui = DataModel.FindFirstChildOfClass("CoreGui")
        ScriptContext = DataModel.FindFirstChildOfClass("ScriptContext")
        RbxReplicatedStorage = DataModel.FindFirstChildOfClass("RobloxReplicatedStorage")

        LocalPlayer = DataModel.FindFirstChildOfClass("Players").LocalPlayer
        RobloxGui = CoreGui.FindFirstChild("RobloxGui")
        Modules = RobloxGui.FindFirstChild("Modules")

        print(LocalPlayer, CoreGui, ScriptContext, RbxReplicatedStorage, RobloxGui, Modules)

        if ScriptContext.FindFirstChild("StarterScript").Address > 1000:
            print("Using in-game method...")

            PlayerList = Modules.FindFirstChild("PlayerList")
            ScriptHook = PlayerList.WaitForChild("PlayerListManager", 5)

            print(PlayerList, ScriptHook)

            if ScriptHook.Address < 1000:
                self.InjectStatus = 1
                return False, "Failed to inject, please relaunch your roblox :(", DEFAULT_CLIENT_INFO

            CorePackages = DataModel.FindFirstChildOfClass("CorePackages")
            ScriptLoader = CorePackages.FindFirstChild("JestGlobals", True)

            print(CorePackages, ScriptLoader)

            if ScriptLoader.Address < 1000:
                self.InjectStatus = 1
                return False, "Failed to fetch ModuleScript :(", DEFAULT_CLIENT_INFO

            ScriptLoader.SetModuleBypass()
            ScriptHook.Spoof(ScriptLoader)

            ScriptLoader.Bytecode = init_script_bytecode
            initialize_script_hook()

            time.sleep(1)
            ScriptHook.Spoof(ScriptHook)
            ScriptLoader.ResetModule()

        else:
            print("Using homepage method...")

            Common = Modules.FindFirstChild("Common")
            PolicyService = Common.FindFirstChild("PolicyService")

            print(Common, PolicyService)

            PolicyService.Bytecode = init_script_bytecode

            print("Waiting for player to leave homepage...")
            EventManager.emit("notification", "Incognito is ready, you may now join any roblox game!")

            self.InjectStatus = 3
            RobloxProcess, RobloxTerminated = psutil.Process(new_pid), False

            while (not RobloxTerminated): # detection for datamodel changes
                try:
                    if (RobloxProcess.status() == "dead"):
                        RobloxTerminated = True
                        break
                except psutil.NoSuchProcess:
                    RobloxTerminated = True
                    break

                NewDataModelHolderAddy = Process.read_longlong(RenderView + Offsets.DataModelHolder)
                if NewDataModelHolderAddy != DataModelAddyHolder:
                    DataModelAddy = Process.read_longlong(NewDataModelHolderAddy + Offsets.DataModel) if NewDataModelHolderAddy else None

                    if (DataModelAddy and DataModelAddy > 1000):
                        break

                time.sleep(1)

            if RobloxTerminated:
                self.InjectStatus = 1
                return False, "Roblox closed while waiting to inject.", DEFAULT_CLIENT_INFO

            DataModel = Instance(DataModelAddy)
            RbxReplicatedStorage = DataModel.FindFirstChildOfClass("RobloxReplicatedStorage")

            print(DataModel, RbxReplicatedStorage)

        BridgeContainer = RbxReplicatedStorage.WaitForChild("Bridge", 15)
        print(BridgeContainer)

        if BridgeContainer.Address < 1000:
            self.InjectStatus = 1
            return False, "Failed to get bridge, please relaunch your roblox :(", DEFAULT_CLIENT_INFO

        print("init script initialized")

        self.BridgeService.Start(new_pid, BridgeContainer)

        self.InjectStatus = 4
        register_callbacks(Bridge=self.BridgeService)
        self.BridgeService.Send("synchronize_files")

        if os.path.isdir("./autoexecute"):
            for file in os.listdir("./autoexecute"):
                full_path = "./autoexecute/" + file

                if os.path.isfile(full_path):
                    with open(full_path, "rb") as file:
                        file_content = file.read().decode(errors="ignore")
                        self.Execute(file_content)
                        time.sleep(0.05)

        return True, "Successfully injected!", [new_pid, LocalPlayer.Name]

    def Execute(self, source):
        if self.InjectStatus == 4 and not self.BridgeService.RobloxTerminated:
            CurrentScript = self.BridgeService.ModuleHolder.Value

            CurrentScript.SetModuleBypass()
            CurrentScript.Bytecode = RBXBytecode.Compile(
                f"return function(...) {source} \nend",
                f"execute-{random_string()}.btc"
            )

            self.BridgeService.Send("load_script")
